module.exports = {
  content: "/******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContentScript\": () => (/* reexport safe */ _contentscript_ContentScript__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _contentscript_ContentScript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n\n\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PILOT_TYPE\": () => (/* binding */ PILOT_TYPE),\n/* harmony export */   \"WORKER_TYPE\": () => (/* binding */ WORKER_TYPE),\n/* harmony export */   \"default\": () => (/* binding */ ContentScript)\n/* harmony export */ });\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var p_wait_for__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);\n/* harmony import */ var p_wait_for__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(p_wait_for__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _cozy_minilog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);\n/* harmony import */ var _cozy_minilog__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_cozy_minilog__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _bridge_LauncherBridge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(74);\n/* harmony import */ var ky_umd__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75);\n/* harmony import */ var ky_umd__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ky_umd__WEBPACK_IMPORTED_MODULE_5__);\n// @ts-check\n\n\n\n\n\n\n\n\nconst log = _cozy_minilog__WEBPACK_IMPORTED_MODULE_2___default()('ContentScript class')\n\nconst s = 1000\nconst m = 60 * s\n\nconst DEFAULT_LOGIN_TIMEOUT = 5 * m\nconst DEFAULT_WAIT_FOR_ELEMENT_TIMEOUT = 30 * s\n\nconst PILOT_TYPE = 'pilot'\nconst WORKER_TYPE = 'worker'\n\nsendContentScriptReadyEvent()\n\nclass ContentScript {\n  /**\n   * Init the bridge communication with the launcher.\n   * It also exposes the methods which will be callable by the launcher\n   *\n   * @param {object} options : options object\n   * @param {Array<string>} [options.additionalExposedMethodsNames] : list of additional method of the\n   * content script to expose expose. To make it callable via the worker\n   */\n  async init(options = {}) {\n    this.bridge = new _bridge_LauncherBridge__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({ localWindow: window })\n    const exposedMethodsNames = [\n      'setContentScriptType',\n      'ensureAuthenticated',\n      'checkAuthenticated',\n      'waitForAuthenticated',\n      'waitForElementNoReload',\n      'getUserDataFromWebsite',\n      'fetch',\n      'click',\n      'fillText',\n      'storeFromWorker',\n      'clickAndWait',\n      'getCookiesByDomain',\n      'getCookieByDomainAndName'\n    ]\n\n    if (options.additionalExposedMethodsNames) {\n      exposedMethodsNames.push.apply(\n        exposedMethodsNames,\n        options.additionalExposedMethodsNames\n      )\n    }\n\n    const exposedMethods = {}\n    // TODO error handling\n    // should catch and call onError on the launcher to let it handle the job update\n    for (const method of exposedMethodsNames) {\n      exposedMethods[method] = this[method].bind(this)\n    }\n    this.store = {}\n    await this.bridge.init({ exposedMethods })\n    window.onbeforeunload = () =>\n      this.log(\n        'window.beforeunload detected with previous url : ' + document.location\n      )\n\n    this.bridge.emit('workerReady')\n  }\n\n  /**\n   * Set the ContentScript type. This is usefull to know which webview is the pilot or the worker\n   *\n   * @param {string} contentScriptType - (\"pilot\" | \"worker\")\n   */\n  async setContentScriptType(contentScriptType) {\n    this.contentScriptType = contentScriptType\n    log.info(`I am the ${contentScriptType}`)\n  }\n\n  /**\n   * Check if the user is authenticated or not. This method is made to be overloaded by the child class\n   *\n   * @returns {Promise.<boolean>} : true if authenticated or false in other case\n   */\n  async checkAuthenticated() {\n    return false\n  }\n\n  /**\n   * This method is made to run in the worker and will resolve as true when\n   * the user is authenticated\n   *\n   * @returns {Promise.<true>} : if authenticated\n   * @throws {Error}: TimeoutError from p-wait-for package if timeout expired\n   */\n  async waitForAuthenticated() {\n    this.onlyIn(WORKER_TYPE, 'waitForAuthenticated')\n    await p_wait_for__WEBPACK_IMPORTED_MODULE_1___default()(this.checkAuthenticated.bind(this), {\n      interval: 1000,\n      timeout: DEFAULT_LOGIN_TIMEOUT\n    })\n    return true\n  }\n\n  /**\n   * Run a specified method in the worker webview\n   *\n   * @param {string} method : name of the method to run\n   */\n  async runInWorker(method, ...args) {\n    this.onlyIn(PILOT_TYPE, 'runInWorker')\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return this.bridge.call('runInWorker', method, ...args)\n  }\n\n  /**\n   * Wait for a method to resolve as true on worker\n   *\n   * @param {object} options        - options object\n   * @param {string} options.method - name of the method to run\n   * @param {number} [options.timeout] - number of miliseconds before the function sends a timeout error. Default Infinity\n   * @param {Array} options.args - array of args to pass to the method\n   * @returns {Promise<boolean>} - true\n   * @throws {Error} - if timeout expired\n   */\n  async runInWorkerUntilTrue({ method, timeout = Infinity, args = [] }) {\n    this.onlyIn(PILOT_TYPE, 'runInWorkerUntilTrue')\n    log.debug('runInWorkerUntilTrue', method)\n    let result = false\n    const start = Date.now()\n    const isTimeout = () => Date.now() - start >= timeout\n    while (!result) {\n      if (isTimeout()) {\n        throw new Error('Timeout error')\n      }\n      log.debug('runInWorker call', method)\n      result = await this.runInWorker(method, ...args)\n      log.debug('runInWorker result', result)\n    }\n    return result\n  }\n\n  /**\n   * Wait for a dom element to be present on the page, even if there are page redirects or page\n   * reloads\n   *\n   * @param {string} selector - css selector we are waiting for\n   */\n  async waitForElementInWorker(selector) {\n    this.onlyIn(PILOT_TYPE, 'waitForElementInWorker')\n    await this.runInWorkerUntilTrue({\n      method: 'waitForElementNoReload',\n      args: [selector]\n    })\n  }\n\n  /**\n   * Wait for a dom element to be present on the page. This won't resolve if the page reloads\n   *\n   * @param {string} selector - css selector we are waiting for\n   * @returns {Promise.<true>} - Returns true when ready\n   */\n  async waitForElementNoReload(selector) {\n    this.onlyIn(WORKER_TYPE, 'waitForElementNoReload')\n    log.debug('waitForElementNoReload', selector)\n    await p_wait_for__WEBPACK_IMPORTED_MODULE_1___default()(() => Boolean(document.querySelector(selector)), {\n      timeout: DEFAULT_WAIT_FOR_ELEMENT_TIMEOUT\n    })\n    return true\n  }\n\n  async click(selector) {\n    this.onlyIn(WORKER_TYPE, 'click')\n    const elem = document.querySelector(selector)\n    if (!elem) {\n      throw new Error(\n        `click: No DOM element is matched with the ${selector} selector`\n      )\n    }\n    elem.click()\n  }\n\n  async clickAndWait(elementToClick, elementToWait) {\n    this.onlyIn(PILOT_TYPE, 'clickAndWait')\n    log.debug('clicking ' + elementToClick)\n    await this.runInWorker('click', elementToClick)\n    log.debug('waiting for ' + elementToWait)\n    await this.waitForElementInWorker(elementToWait)\n    log.debug('done waiting ' + elementToWait)\n  }\n\n  async fillText(selector, text) {\n    this.onlyIn(WORKER_TYPE, 'fillText')\n    const elem = document.querySelector(selector)\n    if (!elem) {\n      throw new Error(\n        `fillText: No DOM element is matched with the ${selector} selector`\n      )\n    }\n    elem.focus()\n    elem.value = text\n    elem.dispatchEvent(new Event('input', { bubbles: true }))\n    elem.dispatchEvent(new Event('change', { bubbles: true }))\n  }\n\n  /**\n   * Bridge to the saveFiles method from the launcher.\n   * - it prefilters files according to the context comming from the launcher\n   * - download files when not filtered out\n   * - converts blob files to base64 uri to be serializable\n   *\n   * @param {Array} entries : list of file entries to save\n   * @param {object} options : saveFiles options\n   */\n  async saveFiles(entries, options) {\n    this.onlyIn(PILOT_TYPE, 'saveFiles')\n    log.debug(entries, 'saveFiles input entries')\n    const context = options.context\n    log.debug(context, 'saveFiles input context')\n\n    const filteredEntries = this.filterOutExistingFiles(entries, options)\n    for (const entry of filteredEntries) {\n      if (entry.fileurl) {\n        entry.blob = await ky_umd__WEBPACK_IMPORTED_MODULE_5___default().get(entry.fileurl, entry.requestOptions).blob()\n        delete entry.fileurl\n      }\n      if (entry.blob) {\n        // TODO paralelize\n        entry.dataUri = await (0,_utils__WEBPACK_IMPORTED_MODULE_4__.blobToBase64)(entry.blob)\n        delete entry.blob\n      }\n    }\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return await this.bridge.call('saveFiles', entries, options)\n  }\n\n  /**\n   * Bridge to the saveBills method from the launcher.\n   * - it first saves the files\n   * - then saves bills linked to corresponding files\n   *\n   * @param {Array} entries : list of file entries to save\n   * @param {object} options : saveFiles options\n   */\n  async saveBills(entries, options) {\n    this.onlyIn(PILOT_TYPE, 'saveBills')\n    const files = await this.saveFiles(entries, options)\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return await this.bridge.call('saveBills', files, options)\n  }\n\n  /**\n   * Bridge to the getCredentials method from the launcher.\n   */\n  async getCredentials() {\n    this.onlyIn(PILOT_TYPE, 'getCredentials')\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return await this.bridge.call('getCredentials')\n  }\n\n  /**\n   * Bridge to the saveCredentials method from the launcher.\n   *\n   * @param {object} credentials : object with credentials specific to the current connector\n   */\n  async saveCredentials(credentials) {\n    this.onlyIn(PILOT_TYPE, 'saveCredentials')\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return await this.bridge.call('saveCredentials', credentials)\n  }\n\n  /**\n   * Bridge to the saveIdentity method from the launcher.\n   *\n   * @param {object} identity : io.cozy.contacts object\n   */\n  async saveIdentity(identity) {\n    this.onlyIn(PILOT_TYPE, 'saveIdentity')\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return await this.bridge.call('saveIdentity', identity)\n  }\n\n  /**\n   * Bridge to the getCookiesByDomain method from the RNlauncher.\n   *\n   * @param {string} domain : domain name\n   */\n  async getCookiesByDomain(domain) {\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return await this.bridge.call('getCookiesByDomain', domain)\n  }\n\n  /**\n   * Bridge to the getCookieFromKeychainByName method from the RNlauncher.\n   *\n   * @param {string} cookieName : cookie name\n   */\n  async getCookieFromKeychainByName(cookieName) {\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return await this.bridge.call('getCookieFromKeychainByName', cookieName)\n  }\n\n  /**\n   * Bridge to the saveCookieToKeychain method from the RNlauncher.\n   *\n   * @param {string} cookieValue : cookie value\n   */\n  async saveCookieToKeychain(cookieValue) {\n    this.onlyIn(PILOT_TYPE, 'saveCookieToKeychain')\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return await this.bridge.call('saveCookieToKeychain', cookieValue)\n  }\n\n  async getCookieByDomainAndName(cookieDomain, cookieName) {\n    this.onlyIn(WORKER_TYPE, 'getCookieByDomainAndName')\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    const expectedCookie = await this.bridge.call(\n      'getCookieByDomainAndName',\n      cookieDomain,\n      cookieName\n    )\n    return expectedCookie\n  }\n\n  /**\n   * Do not download files which already exist\n   *\n   * @param {Array} files : array of file objects\n   * @param {object} options : options object\n   * @param {Array.<string>} options.fileIdAttributes : list of attributes defining the unicity of the file\n   * @param {object} options.context : current launcher context\n   * @returns {Array} : filtered array of file objects\n   */\n  filterOutExistingFiles(files, options) {\n    if (options.fileIdAttributes) {\n      const contextFilesIndex = this.createContextFilesIndex(\n        options.context,\n        options.fileIdAttributes\n      )\n      return files.filter(\n        file =>\n          contextFilesIndex[\n            this.calculateFileKey(file, options.fileIdAttributes)\n          ] === undefined\n      )\n    } else {\n      return files\n    }\n  }\n\n  /**\n   * Creates an index of files, indexed by uniq id defined by fileIdAttributes\n   *\n   * @param {object} context : current context object\n   * @param {Array.<string>} fileIdAttributes : list of attributes defining the unicity of a file\n   * @returns {object} : context file index\n   */\n  createContextFilesIndex(context, fileIdAttributes) {\n    log.debug('getContextFilesIndex', context, fileIdAttributes)\n    let index = {}\n    for (const entry of context) {\n      index[entry.metadata.fileIdAttributes] = entry\n    }\n    return index\n  }\n\n  /**\n   * Calculates the key defining the uniqueness of a given file\n   *\n   * @param {object} file : file object\n   * @param {Array.<string>} fileIdAttributes : list of attributes defining the unicity of a file\n   * @returns {string} : file key\n   */\n  calculateFileKey(file, fileIdAttributes) {\n    return fileIdAttributes\n      .sort()\n      .map(key => lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(file, key))\n      .join('####')\n  }\n\n  /**\n   * Send log message to the launcher\n   *\n   * @param {string} message : the log message\n   * @todo Use cozy-logger to add logging level and other features\n   */\n  log(message) {\n    this.bridge?.emit('log', message)\n  }\n\n  /**\n   * @typedef SetWorkerStateOptions\n   * @property {string} [url]      : url displayed by the worker webview for the login\n   * @property {boolean} [visible] : will the worker be visible or not\n   */\n\n  /**\n   * This is a proxy to the \"setWorkerState\" command in the launcher\n   *\n   * @param {SetWorkerStateOptions} options : worker state options\n   */\n  async setWorkerState(options = {}) {\n    this.onlyIn(PILOT_TYPE, 'setWorkerState')\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    await this.bridge.call('setWorkerState', options)\n  }\n\n  /**\n   * Set the current url of the worker\n   *\n   * @param {string} url : the url\n   */\n  async goto(url) {\n    this.onlyIn(PILOT_TYPE, 'goto')\n    await this.setWorkerState({ url })\n  }\n\n  /**\n   * Make sur that the connector is authenticated to the website.\n   * If not, show the login webview to the user to let her/him authenticated.\n   * Resolve the promise when authenticated\n   *\n   * @throws LOGIN_FAILED\n   * @returns {Promise.<boolean>} : true if the user is authenticated\n   */\n  async ensureAuthenticated() {\n    return true\n  }\n\n  /**\n   * Returns whatever unique information on the authenticated user which will be usefull\n   * to identify fetched data : destination folder name, fetched data metadata\n   *\n   * @returns {Promise.<object>}  : user data object\n   */\n  async getUserDataFromWebsite() {}\n\n  /**\n   * In worker context, send the given data to the pilot to be stored in its own store\n   *\n   * @param {object} obj : any object with data to store\n   */\n  async sendToPilot(obj) {\n    this.onlyIn(WORKER_TYPE, 'sendToPilot')\n    if (!this.bridge) {\n      throw new Error(\n        'No bridge is defined, you should call ContentScript.init before using this method'\n      )\n    }\n    return this.bridge.call('sendToPilot', obj)\n  }\n\n  /**\n   * Store data sent from worker with sendToPilot method\n   *\n   * @param {object} obj : any object with data to store\n   */\n  async storeFromWorker(obj) {\n    // @ts-ignore Aucune surcharge ne correspond à cet appel.\n    Object.assign(this.store, obj)\n  }\n\n  onlyIn(csType, method) {\n    if (this.contentScriptType !== csType) {\n      throw new Error(`Use ${method} only from the ${csType}`)\n    }\n  }\n\n  /**\n   * Main function, fetches all connector data and save it to the cozy\n   *\n   * @param {object} options : options object\n   * @param {object} options.context : all the data already fetched by the connector in a previous execution. Will be usefull to optimize\n   * connector execution by not fetching data we already have.\n   * @returns {Promise.<object>} : Connector execution result. TBD\n   */\n  // eslint-disable-next-line no-unused-vars\n  async fetch(options) {}\n}\n\nfunction sendContentScriptReadyEvent() {\n  // @ts-ignore La propriété 'ReactNativeWebView' n'existe pas sur le type 'Window & typeof globalThis'.\n  if (window.ReactNativeWebView?.postMessage) {\n    // @ts-ignore La propriété 'ReactNativeWebView' n'existe pas sur le type 'Window & typeof globalThis'.\n    window.ReactNativeWebView?.postMessage(\n      JSON.stringify({ message: 'NEW_WORKER_INITIALIZING' })\n    )\n  } else {\n    log.error('No window.ReactNativeWebView.postMessage available')\n  }\n}\n\n\n/***/ }),\n/* 3 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseGet = __webpack_require__(4);\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n\n/***/ }),\n/* 4 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar castPath = __webpack_require__(5),\n    toKey = __webpack_require__(54);\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n\n/***/ }),\n/* 5 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isArray = __webpack_require__(6),\n    isKey = __webpack_require__(7),\n    stringToPath = __webpack_require__(16),\n    toString = __webpack_require__(51);\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n\n\n/***/ }),\n/* 6 */\n/***/ ((module) => {\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n/***/ }),\n/* 7 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isArray = __webpack_require__(6),\n    isSymbol = __webpack_require__(8);\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n\n\n/***/ }),\n/* 8 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseGetTag = __webpack_require__(9),\n    isObjectLike = __webpack_require__(15);\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n/***/ }),\n/* 9 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Symbol = __webpack_require__(10),\n    getRawTag = __webpack_require__(13),\n    objectToString = __webpack_require__(14);\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n/***/ }),\n/* 10 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar root = __webpack_require__(11);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n/***/ }),\n/* 11 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar freeGlobal = __webpack_require__(12);\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n/***/ }),\n/* 12 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\nmodule.exports = freeGlobal;\n\n\n/***/ }),\n/* 13 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Symbol = __webpack_require__(10);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n/***/ }),\n/* 14 */\n/***/ ((module) => {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n/***/ }),\n/* 15 */\n/***/ ((module) => {\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n/***/ }),\n/* 16 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar memoizeCapped = __webpack_require__(17);\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n\n\n/***/ }),\n/* 17 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar memoize = __webpack_require__(18);\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n\n\n/***/ }),\n/* 18 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar MapCache = __webpack_require__(19);\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n\n\n/***/ }),\n/* 19 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar mapCacheClear = __webpack_require__(20),\n    mapCacheDelete = __webpack_require__(45),\n    mapCacheGet = __webpack_require__(48),\n    mapCacheHas = __webpack_require__(49),\n    mapCacheSet = __webpack_require__(50);\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n/***/ }),\n/* 20 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Hash = __webpack_require__(21),\n    ListCache = __webpack_require__(36),\n    Map = __webpack_require__(44);\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n/***/ }),\n/* 21 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar hashClear = __webpack_require__(22),\n    hashDelete = __webpack_require__(32),\n    hashGet = __webpack_require__(33),\n    hashHas = __webpack_require__(34),\n    hashSet = __webpack_require__(35);\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n/***/ }),\n/* 22 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar nativeCreate = __webpack_require__(23);\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n\n/***/ }),\n/* 23 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getNative = __webpack_require__(24);\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n/***/ }),\n/* 24 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseIsNative = __webpack_require__(25),\n    getValue = __webpack_require__(31);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n/***/ }),\n/* 25 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isFunction = __webpack_require__(26),\n    isMasked = __webpack_require__(28),\n    isObject = __webpack_require__(27),\n    toSource = __webpack_require__(30);\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n/***/ }),\n/* 26 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseGetTag = __webpack_require__(9),\n    isObject = __webpack_require__(27);\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n/* 27 */\n/***/ ((module) => {\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n/***/ }),\n/* 28 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar coreJsData = __webpack_require__(29);\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n/***/ }),\n/* 29 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar root = __webpack_require__(11);\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n/***/ }),\n/* 30 */\n/***/ ((module) => {\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n/***/ }),\n/* 31 */\n/***/ ((module) => {\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n/***/ }),\n/* 32 */\n/***/ ((module) => {\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n\n/***/ }),\n/* 33 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar nativeCreate = __webpack_require__(23);\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n/***/ }),\n/* 34 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar nativeCreate = __webpack_require__(23);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n/***/ }),\n/* 35 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar nativeCreate = __webpack_require__(23);\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n/***/ }),\n/* 36 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar listCacheClear = __webpack_require__(37),\n    listCacheDelete = __webpack_require__(38),\n    listCacheGet = __webpack_require__(41),\n    listCacheHas = __webpack_require__(42),\n    listCacheSet = __webpack_require__(43);\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n/***/ }),\n/* 37 */\n/***/ ((module) => {\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n\n/***/ }),\n/* 38 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assocIndexOf = __webpack_require__(39);\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n/***/ }),\n/* 39 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar eq = __webpack_require__(40);\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n/***/ }),\n/* 40 */\n/***/ ((module) => {\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n/***/ }),\n/* 41 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assocIndexOf = __webpack_require__(39);\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n/***/ }),\n/* 42 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assocIndexOf = __webpack_require__(39);\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n/***/ }),\n/* 43 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar assocIndexOf = __webpack_require__(39);\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n/***/ }),\n/* 44 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getNative = __webpack_require__(24),\n    root = __webpack_require__(11);\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n/***/ }),\n/* 45 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getMapData = __webpack_require__(46);\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n\n/***/ }),\n/* 46 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isKeyable = __webpack_require__(47);\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n/***/ }),\n/* 47 */\n/***/ ((module) => {\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n/***/ }),\n/* 48 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getMapData = __webpack_require__(46);\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n/***/ }),\n/* 49 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getMapData = __webpack_require__(46);\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n/***/ }),\n/* 50 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar getMapData = __webpack_require__(46);\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n/***/ }),\n/* 51 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar baseToString = __webpack_require__(52);\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n\n\n/***/ }),\n/* 52 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Symbol = __webpack_require__(10),\n    arrayMap = __webpack_require__(53),\n    isArray = __webpack_require__(6),\n    isSymbol = __webpack_require__(8);\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n\n\n/***/ }),\n/* 53 */\n/***/ ((module) => {\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n\n\n/***/ }),\n/* 54 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar isSymbol = __webpack_require__(8);\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n\n\n/***/ }),\n/* 55 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\nconst pTimeout = __webpack_require__(56);\n\nconst pWaitFor = async (condition, options) => {\n\toptions = {\n\t\tinterval: 20,\n\t\ttimeout: Infinity,\n\t\tleadingCheck: true,\n\t\t...options\n\t};\n\n\tlet retryTimeout;\n\n\tconst promise = new Promise((resolve, reject) => {\n\t\tconst check = async () => {\n\t\t\ttry {\n\t\t\t\tconst value = await condition();\n\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError('Expected condition to return a boolean');\n\t\t\t\t}\n\n\t\t\t\tif (value === true) {\n\t\t\t\t\tresolve();\n\t\t\t\t} else {\n\t\t\t\t\tretryTimeout = setTimeout(check, options.interval);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t};\n\n\t\tif (options.leadingCheck) {\n\t\t\tcheck();\n\t\t} else {\n\t\t\tretryTimeout = setTimeout(check, options.interval);\n\t\t}\n\t});\n\n\tif (options.timeout !== Infinity) {\n\t\ttry {\n\t\t\treturn await pTimeout(promise, options.timeout);\n\t\t} catch (error) {\n\t\t\tif (retryTimeout) {\n\t\t\t\tclearTimeout(retryTimeout);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\treturn promise;\n};\n\nmodule.exports = pWaitFor;\n// TODO: Remove this for the next major release\nmodule.exports[\"default\"] = pWaitFor;\n\n\n/***/ }),\n/* 56 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\n\n\nconst pFinally = __webpack_require__(57);\n\nclass TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\nconst pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {\n\tif (typeof milliseconds !== 'number' || milliseconds < 0) {\n\t\tthrow new TypeError('Expected `milliseconds` to be a positive number');\n\t}\n\n\tif (milliseconds === Infinity) {\n\t\tresolve(promise);\n\t\treturn;\n\t}\n\n\tconst timer = setTimeout(() => {\n\t\tif (typeof fallback === 'function') {\n\t\t\ttry {\n\t\t\t\tresolve(fallback());\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\tif (typeof promise.cancel === 'function') {\n\t\t\tpromise.cancel();\n\t\t}\n\n\t\treject(timeoutError);\n\t}, milliseconds);\n\n\t// TODO: Use native `finally` keyword when targeting Node.js 10\n\tpFinally(\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tpromise.then(resolve, reject),\n\t\t() => {\n\t\t\tclearTimeout(timer);\n\t\t}\n\t);\n});\n\nmodule.exports = pTimeout;\n// TODO: Remove this for the next major release\nmodule.exports[\"default\"] = pTimeout;\n\nmodule.exports.TimeoutError = TimeoutError;\n\n\n/***/ }),\n/* 57 */\n/***/ ((module) => {\n\n\"use strict\";\n\nmodule.exports = (promise, onFinally) => {\n\tonFinally = onFinally || (() => {});\n\n\treturn promise.then(\n\t\tval => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => val),\n\t\terr => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => {\n\t\t\tthrow err;\n\t\t})\n\t);\n};\n\n\n/***/ }),\n/* 58 */\n/***/ ((module, exports, __webpack_require__) => {\n\nvar Minilog = __webpack_require__(59);\n\nvar oldEnable = Minilog.enable,\n    oldDisable = Minilog.disable,\n    isChrome = (typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent)),\n    console = __webpack_require__(63);\n\n// Use a more capable logging backend if on Chrome\nMinilog.defaultBackend = (isChrome ? console.minilog : console);\n\n// apply enable inputs from localStorage and from the URL\nif(typeof window != 'undefined') {\n  try {\n    Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));\n  } catch(e) {}\n  if(window.location && window.location.search) {\n    var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);\n    match && Minilog.enable(decodeURIComponent(match[1]));\n  }\n}\n\n// Make enable also add to localStorage\nMinilog.enable = function() {\n  oldEnable.call(Minilog, true);\n  try { window.localStorage['minilogSettings'] = JSON.stringify(true); } catch(e) {}\n  return this;\n};\n\nMinilog.disable = function() {\n  oldDisable.call(Minilog);\n  try { delete window.localStorage.minilogSettings; } catch(e) {}\n  return this;\n};\n\nexports = module.exports = Minilog;\n\nexports.backends = {\n  array: __webpack_require__(67),\n  browser: Minilog.defaultBackend,\n  localStorage: __webpack_require__(68),\n  jQuery: __webpack_require__(69)\n};\n\n\n/***/ }),\n/* 59 */\n/***/ ((module, exports, __webpack_require__) => {\n\nvar Transform = __webpack_require__(60),\n    Filter = __webpack_require__(62);\n\nvar log = new Transform(),\n    slice = Array.prototype.slice;\n\nexports = module.exports = function create(name) {\n  var o   = function() { log.write(name, undefined, slice.call(arguments)); return o; };\n  o.debug = function() { log.write(name, 'debug', slice.call(arguments)); return o; };\n  o.info  = function() { log.write(name, 'info',  slice.call(arguments)); return o; };\n  o.warn  = function() { log.write(name, 'warn',  slice.call(arguments)); return o; };\n  o.error = function() { log.write(name, 'error', slice.call(arguments)); return o; };\n  o.group = function() { log.write(name, 'group', slice.call(arguments)); return o; };\n  o.groupEnd = function() { log.write(name, 'groupEnd', slice.call(arguments)); return o; };\n  o.log   = o.debug; // for interface compliance with Node and browser consoles\n  o.suggest = exports.suggest;\n  o.format = log.format;\n  return o;\n};\n\n// filled in separately\nexports.defaultBackend = exports.defaultFormatter = null;\n\nexports.pipe = function(dest) {\n  return log.pipe(dest);\n};\n\nexports.end = exports.unpipe = exports.disable = function(from) {\n  return log.unpipe(from);\n};\n\nexports.Transform = Transform;\nexports.Filter = Filter;\n// this is the default filter that's applied when .enable() is called normally\n// you can bypass it completely and set up your own pipes\nexports.suggest = new Filter();\n\nexports.enable = function() {\n  if(exports.defaultFormatter) {\n    return log.pipe(exports.suggest) // filter\n              .pipe(exports.defaultFormatter) // formatter\n              .pipe(exports.defaultBackend); // backend\n  }\n  return log.pipe(exports.suggest) // filter\n            .pipe(exports.defaultBackend); // formatter\n};\n\n\n\n/***/ }),\n/* 60 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar microee = __webpack_require__(61);\n\n// Implements a subset of Node's stream.Transform - in a cross-platform manner.\nfunction Transform() {}\n\nmicroee.mixin(Transform);\n\n// The write() signature is different from Node's\n// --> makes it much easier to work with objects in logs.\n// One of the lessons from v1 was that it's better to target\n// a good browser rather than the lowest common denominator\n// internally.\n// If you want to use external streams, pipe() to ./stringify.js first.\nTransform.prototype.write = function(name, level, args) {\n  this.emit('item', name, level, args);\n};\n\nTransform.prototype.end = function() {\n  this.emit('end');\n  this.removeAllListeners();\n};\n\nTransform.prototype.pipe = function(dest) {\n  var s = this;\n  // prevent double piping\n  s.emit('unpipe', dest);\n  // tell the dest that it's being piped to\n  dest.emit('pipe', s);\n\n  function onItem() {\n    dest.write.apply(dest, Array.prototype.slice.call(arguments));\n  }\n  function onEnd() { !dest._isStdio && dest.end(); }\n\n  s.on('item', onItem);\n  s.on('end', onEnd);\n\n  s.when('unpipe', function(from) {\n    var match = (from === dest) || typeof from == 'undefined';\n    if(match) {\n      s.removeListener('item', onItem);\n      s.removeListener('end', onEnd);\n      dest.emit('unpipe');\n    }\n    return match;\n  });\n\n  return dest;\n};\n\nTransform.prototype.unpipe = function(from) {\n  this.emit('unpipe', from);\n  return this;\n};\n\nTransform.prototype.format = function(dest) {\n  throw new Error([\n    'Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:',\n    'var Minilog = require(\\'minilog\\');',\n    'Minilog',\n    '  .pipe(Minilog.backends.console.formatClean)',\n    '  .pipe(Minilog.backends.console);'].join('\\n'));\n};\n\nTransform.mixin = function(dest) {\n  var o = Transform.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\n\nmodule.exports = Transform;\n\n\n/***/ }),\n/* 61 */\n/***/ ((module) => {\n\nfunction M() { this._events = {}; }\nM.prototype = {\n  on: function(ev, cb) {\n    this._events || (this._events = {});\n    var e = this._events;\n    (e[ev] || (e[ev] = [])).push(cb);\n    return this;\n  },\n  removeListener: function(ev, cb) {\n    var e = this._events[ev] || [], i;\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }\n    }\n  },\n  removeAllListeners: function(ev) {\n    if(!ev) { this._events = {}; }\n    else { this._events[ev] && (this._events[ev] = []); }\n  },\n  listeners: function(ev) {\n    return (this._events ? this._events[ev] || [] : []);\n  },\n  emit: function(ev) {\n    this._events || (this._events = {});\n    var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      e[i].apply(this, args);\n    }\n    return this;\n  },\n  when: function(ev, cb) {\n    return this.once(ev, cb, true);\n  },\n  once: function(ev, cb, when) {\n    if(!cb) return this;\n    function c() {\n      if(!when) this.removeListener(ev, c);\n      if(cb.apply(this, arguments) && when) this.removeListener(ev, c);\n    }\n    c.cb = cb;\n    this.on(ev, c);\n    return this;\n  }\n};\nM.mixin = function(dest) {\n  var o = M.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\nmodule.exports = M;\n\n\n/***/ }),\n/* 62 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n// default filter\nvar Transform = __webpack_require__(60);\n\nvar levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\n\nfunction Filter() {\n  this.enabled = true;\n  this.defaultResult = true;\n  this.clear();\n}\n\nTransform.mixin(Filter);\n\n// allow all matching, with level >= given level\nFilter.prototype.allow = function(name, level) {\n  this._white.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\n// deny all matching, with level <= given level\nFilter.prototype.deny = function(name, level) {\n  this._black.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\nFilter.prototype.clear = function() {\n  this._white = [];\n  this._black = [];\n  return this;\n};\n\nfunction test(rule, name) {\n  // use .test for RegExps\n  return (rule.n.test ? rule.n.test(name) : rule.n == name);\n};\n\nFilter.prototype.test = function(name, level) {\n  var i, len = Math.max(this._white.length, this._black.length);\n  for(i = 0; i < len; i++) {\n    if(this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {\n      return true;\n    }\n    if(this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {\n      return false;\n    }\n  }\n  return this.defaultResult;\n};\n\nFilter.prototype.write = function(name, level, args) {\n  if(!this.enabled || this.test(name, level)) {\n    return this.emit('item', name, level, args);\n  }\n};\n\nmodule.exports = Filter;\n\n\n/***/ }),\n/* 63 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Transform = __webpack_require__(60);\n\nvar newlines = /\\n+$/,\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var i = args.length-1;\n  if (typeof console === 'undefined' || !console.log) {\n    return;\n  }\n  if(console.log.apply) {\n    return console.log.apply(console, [name, level].concat(args));\n  } else if(JSON && JSON.stringify) {\n    // console.log.apply is undefined in IE8 and IE9\n    // for IE8/9: make console.log at least a bit less awful\n    if(args[i] && typeof args[i] == 'string') {\n      args[i] = args[i].replace(newlines, '');\n    }\n    try {\n      for(i = 0; i < args.length; i++) {\n        args[i] = JSON.stringify(args[i]);\n      }\n    } catch(e) {}\n    console.log(args.join(' '));\n  }\n};\n\nlogger.formatters = ['color', 'minilog'];\nlogger.color = __webpack_require__(64);\nlogger.minilog = __webpack_require__(66);\n\nmodule.exports = logger;\n\n\n/***/ }),\n/* 64 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Transform = __webpack_require__(60),\n    color = __webpack_require__(65);\n\nvar colors = { debug: ['cyan'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(console[level] && console[level].apply) {\n    fn = console[level];\n    fn.apply(console, [ '%c'+name+' %c'+level, color('gray'), color.apply(color, colors[level])].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n\n\n/***/ }),\n/* 65 */\n/***/ ((module) => {\n\nvar hex = {\n  black: '#000',\n  red: '#c23621',\n  green: '#25bc26',\n  yellow: '#bbbb00',\n  blue:  '#492ee1',\n  magenta: '#d338d3',\n  cyan: '#33bbc8',\n  gray: '#808080',\n  purple: '#708'\n};\nfunction color(fg, isInverse) {\n  if(isInverse) {\n    return 'color: #fff; background: '+hex[fg]+';';\n  } else {\n    return 'color: '+hex[fg]+';';\n  }\n}\n\nmodule.exports = color;\n\n\n/***/ }),\n/* 66 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Transform = __webpack_require__(60),\n    color = __webpack_require__(65),\n    colors = { debug: ['gray'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(level != 'debug' && console[level]) {\n    fn = console[level];\n  }\n\n  var subset = [], i = 0;\n  if(level != 'info') {\n    for(; i < args.length; i++) {\n      if(typeof args[i] != 'string') break;\n    }\n    fn.apply(console, [ '%c'+name +' '+ args.slice(0, i).join(' '), color.apply(color, colors[level]) ].concat(args.slice(i)));\n  } else {\n    fn.apply(console, [ '%c'+name, color.apply(color, colors[level]) ].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n\n\n/***/ }),\n/* 67 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Transform = __webpack_require__(60),\n    cache = [ ];\n\nvar logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  cache.push([ name, level, args ]);\n};\n\n// utility functions\nlogger.get = function() { return cache; };\nlogger.empty = function() { cache = []; };\n\nmodule.exports = logger;\n\n\n/***/ }),\n/* 68 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Transform = __webpack_require__(60),\n    cache = false;\n\nvar logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  if(typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;\n  try {\n    if(!cache) { cache = (window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : []); }\n    cache.push([ new Date().toString(), name, level, args ]);\n    window.localStorage.minilog = JSON.stringify(cache);\n  } catch(e) {}\n};\n\nmodule.exports = logger;\n\n/***/ }),\n/* 69 */\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\nvar Transform = __webpack_require__(60);\n\nvar cid = new Date().valueOf().toString(36);\n\nfunction AjaxLogger(options) {\n  this.url = options.url || '';\n  this.cache = [];\n  this.timer = null;\n  this.interval = options.interval || 30*1000;\n  this.enabled = true;\n  this.jQuery = window.jQuery;\n  this.extras = {};\n}\n\nTransform.mixin(AjaxLogger);\n\nAjaxLogger.prototype.write = function(name, level, args) {\n  if(!this.timer) { this.init(); }\n  this.cache.push([name, level].concat(args));\n};\n\nAjaxLogger.prototype.init = function() {\n  if(!this.enabled || !this.jQuery) return;\n  var self = this;\n  this.timer = setTimeout(function() {\n    var i, logs = [], ajaxData, url = self.url;\n    if(self.cache.length == 0) return self.init();\n    // Test each log line and only log the ones that are valid (e.g. don't have circular references).\n    // Slight performance hit but benefit is we log all valid lines.\n    for(i = 0; i < self.cache.length; i++) {\n      try {\n        JSON.stringify(self.cache[i]);\n        logs.push(self.cache[i]);\n      } catch(e) { }\n    }\n    if(self.jQuery.isEmptyObject(self.extras)) {\n        ajaxData = JSON.stringify({ logs: logs });\n        url = self.url + '?client_id=' + cid;\n    } else {\n        ajaxData = JSON.stringify(self.jQuery.extend({logs: logs}, self.extras));\n    }\n\n    self.jQuery.ajax(url, {\n      type: 'POST',\n      cache: false,\n      processData: false,\n      data: ajaxData,\n      contentType: 'application/json',\n      timeout: 10000\n    }).success(function(data, status, jqxhr) {\n      if(data.interval) {\n        self.interval = Math.max(1000, data.interval);\n      }\n    }).error(function() {\n      self.interval = 30000;\n    }).always(function() {\n      self.init();\n    });\n    self.cache = [];\n  }, this.interval);\n};\n\nAjaxLogger.prototype.end = function() {};\n\n// wait until jQuery is defined. Useful if you don't control the load order.\nAjaxLogger.jQueryWait = function(onDone) {\n  if(typeof window !== 'undefined' && (window.jQuery || window.$)) {\n    return onDone(window.jQuery || window.$);\n  } else if (typeof window !== 'undefined') {\n    setTimeout(function() { AjaxLogger.jQueryWait(onDone); }, 200);\n  }\n};\n\nmodule.exports = AjaxLogger;\n\n\n/***/ }),\n/* 70 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LauncherBridge)\n/* harmony export */ });\n/* harmony import */ var post_me__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73);\n/* harmony import */ var _ContentScriptMessenger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);\n/* harmony import */ var _bridgeInterfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72);\n\n\n\n\n/**\n * Bridge to the Launcher object via post-me\n */\nclass LauncherBridge extends _bridgeInterfaces__WEBPACK_IMPORTED_MODULE_1__.Bridge {\n  /**\n   * Init the window which will be used to communicate with the launcher\n   *\n   * @param {object} options             : option object\n   * @param {object} options.localWindow : The window used to communicate with the launcher\n   */\n  constructor({ localWindow }) {\n    super()\n    this.localWindow = localWindow\n  }\n\n  async init({ exposedMethods = {} } = {}) {\n    const messenger = new _ContentScriptMessenger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      localWindow: this.localWindow\n    })\n    this.connection = await (0,post_me__WEBPACK_IMPORTED_MODULE_2__.ChildHandshake)(messenger, exposedMethods)\n    this.localHandle = this.connection.localHandle()\n    this.remoteHandle = this.connection.remoteHandle()\n  }\n}\n\n\n/***/ }),\n/* 71 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReactNativeWebviewMessenger)\n/* harmony export */ });\n/* harmony import */ var _bridgeInterfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72);\n// @ts-check\n\n\n/**\n * post-me messenger implementation for a content script implanted in a react native webview\n */\nclass ReactNativeWebviewMessenger extends _bridgeInterfaces__WEBPACK_IMPORTED_MODULE_0__.MessengerInterface {\n  /**\n   * Init the window which will be used to post messages and listen to messages\n   *\n   * @param  {object} options             : options object\n   * @param  {object} options.localWindow : The window object\n   */\n  constructor({ localWindow }) {\n    super()\n    this.localWindow = localWindow\n  }\n  postMessage(message) {\n    this.localWindow.ReactNativeWebView.postMessage(JSON.stringify(message))\n  }\n  addMessageListener(listener) {\n    const outerListener = event => {\n      listener(event)\n    }\n\n    this.localWindow.addEventListener('message', outerListener)\n\n    const removeMessageListener = () => {\n      this.localWindow.removeEventListener('message', outerListener)\n    }\n\n    return removeMessageListener\n  }\n}\n\n\n/***/ }),\n/* 72 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bridge\": () => (/* binding */ Bridge),\n/* harmony export */   \"MessengerInterface\": () => (/* binding */ MessengerInterface)\n/* harmony export */ });\n/* eslint-disable no-unused-vars */\n/**\n * @typedef PostMeConnection\n * @property {Function} localHandle  : get handle to the local end of the connection\n * @property {Function} remoteHandle : get handle to the remote end of the connection\n * @property {Function} close        : stop listening to incoming message from the other side\n */\n\n/**\n * All bridges are supposed to implement this interface\n */\nclass Bridge {\n  /**\n   * Initialize the communication between the parent and the child via post-me protocol\n   * https://github.com/alesgenova/post-me\n   *\n   * @param  {object} options                             : Options object\n   * @param  {object} options.root                        : The object which will contain the exposed method names\n   * @param  {Array.<string>} options.exposedMethodNames  : The list of method names of the root object, which will be exposed via the post-me interface to the content script\n   * @param  {Array.<string>} options.listenedEventsNames : The list of method names of the root object, which will be call on given event name via the post-me interface to the content script\n   * @param  {object} options.webViewRef                  : Reference to the webview obect containing the content script\n   * @returns {Promise.<PostMeConnection>} : the resulting post-me connection\n   */\n  async init(options) {}\n\n  /**\n   * Shortcut to remoteHandle.call method\n   *\n   * @param  {string} method : The remote method name\n   * @param  {Array} args    : Any number of parameters which will be given to the remote method.\n   * It is also possible to pass callback functions (which must support serialization). post-me\n   * will wait the the remote method end before resolving the promise\n   * @returns {Promise.<any>} remote method return value\n   */\n  async call(method, ...args) {\n    return this.remoteHandle.call(method, ...args)\n  }\n\n  /**\n   * Shortcut to localHandle.emit method. Will emit an event which could be listened by the remote\n   * object\n   *\n   * @param  {string} eventName : Name of the event\n   * @param  {Array} args       : Any number of parameters.\n   */\n  emit(eventName, ...args) {\n    this.localHandle.emit(eventName, ...args)\n  }\n\n  /**\n   * Shortcut to remoteHandle.addEventListener method. Will listen to the given event on the remote\n   * object and call the listener function\n   *\n   * @param  {string} remoteEventName : Name of the remove event\n   * @param  {Function} listener      : Listener function\n   */\n  addEventListener(remoteEventName, listener) {\n    this.remoteHandle.addEventListener(remoteEventName, listener)\n  }\n\n  /**\n   * Shortcut to remoteHandle.removeEventListener method. Will stop listening to the given event\n   * on the remote object.\n   *\n   * @param  {string} remoteEventName : Name of the remote event\n   * @param  {Function} listener      : Previously defined listener function\n   */\n  removeEventListener(remoteEventName, listener) {\n    this.remoteHandle.removeEventListener(remoteEventName, listener)\n  }\n}\n\n/**\n * All messengers are supposed to implement this interface\n *\n * @interface\n */\nclass MessengerInterface {\n  /**\n   * Send a message to the other context\n   *\n   * @param {string} message : The payload of the message\n   */\n  postMessage(message) {}\n\n  /**\n   * Add a listener to messages received by the other context\n   *\n   * @param {Function} listener : A listener that will receive the MessageEvent\n   * @returns {Function} A function that can be invoked to remove the listener\n   */\n  addMessageListener(listener) {}\n}\n\n\n/***/ }),\n/* 73 */\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BareMessenger\": () => (/* binding */ BareMessenger),\n/* harmony export */   \"ChildHandshake\": () => (/* binding */ ChildHandshake),\n/* harmony export */   \"ConcreteEmitter\": () => (/* binding */ ConcreteEmitter),\n/* harmony export */   \"DebugMessenger\": () => (/* binding */ DebugMessenger),\n/* harmony export */   \"ParentHandshake\": () => (/* binding */ ParentHandshake),\n/* harmony export */   \"PortMessenger\": () => (/* binding */ PortMessenger),\n/* harmony export */   \"WindowMessenger\": () => (/* binding */ WindowMessenger),\n/* harmony export */   \"WorkerMessenger\": () => (/* binding */ WorkerMessenger),\n/* harmony export */   \"debug\": () => (/* binding */ debug)\n/* harmony export */ });\nconst MARKER = '@post-me';\nfunction createUniqueIdFn() {\n    let __id = 0;\n    return function () {\n        const id = __id;\n        __id += 1;\n        return id;\n    };\n}\n\n/**\n * A concrete implementation of the {@link Emitter} interface\n *\n * @public\n */\nclass ConcreteEmitter {\n    constructor() {\n        this._listeners = {};\n    }\n    /** {@inheritDoc Emitter.addEventListener} */\n    addEventListener(eventName, listener) {\n        let listeners = this._listeners[eventName];\n        if (!listeners) {\n            listeners = new Set();\n            this._listeners[eventName] = listeners;\n        }\n        listeners.add(listener);\n    }\n    /** {@inheritDoc Emitter.removeEventListener} */\n    removeEventListener(eventName, listener) {\n        let listeners = this._listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        listeners.delete(listener);\n    }\n    /** {@inheritDoc Emitter.once} */\n    once(eventName) {\n        return new Promise((resolve) => {\n            const listener = (data) => {\n                this.removeEventListener(eventName, listener);\n                resolve(data);\n            };\n            this.addEventListener(eventName, listener);\n        });\n    }\n    /** @internal */\n    emit(eventName, data) {\n        let listeners = this._listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        listeners.forEach((listener) => {\n            listener(data);\n        });\n    }\n    /** @internal */\n    removeAllListeners() {\n        Object.values(this._listeners).forEach((listeners) => {\n            if (listeners) {\n                listeners.clear();\n            }\n        });\n    }\n}\n\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"HandshakeRequest\"] = \"handshake-request\";\n    MessageType[\"HandshakeResponse\"] = \"handshake-response\";\n    MessageType[\"Call\"] = \"call\";\n    MessageType[\"Response\"] = \"response\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Event\"] = \"event\";\n    MessageType[\"Callback\"] = \"callback\";\n})(MessageType || (MessageType = {}));\n// Message Creators\nfunction createHandshakeRequestMessage(sessionId) {\n    return {\n        type: MARKER,\n        action: MessageType.HandshakeRequest,\n        sessionId,\n    };\n}\nfunction createHandshakeResponseMessage(sessionId) {\n    return {\n        type: MARKER,\n        action: MessageType.HandshakeResponse,\n        sessionId,\n    };\n}\nfunction createCallMessage(sessionId, requestId, methodName, args) {\n    return {\n        type: MARKER,\n        action: MessageType.Call,\n        sessionId,\n        requestId,\n        methodName,\n        args,\n    };\n}\nfunction createResponsMessage(sessionId, requestId, result, error) {\n    const message = {\n        type: MARKER,\n        action: MessageType.Response,\n        sessionId,\n        requestId,\n    };\n    if (result !== undefined) {\n        message.result = result;\n    }\n    if (error !== undefined) {\n        message.error = error;\n    }\n    return message;\n}\nfunction createCallbackMessage(sessionId, requestId, callbackId, args) {\n    return {\n        type: MARKER,\n        action: MessageType.Callback,\n        sessionId,\n        requestId,\n        callbackId,\n        args,\n    };\n}\nfunction createEventMessage(sessionId, eventName, payload) {\n    return {\n        type: MARKER,\n        action: MessageType.Event,\n        sessionId,\n        eventName,\n        payload,\n    };\n}\n// Type Guards\nfunction isMessage(m) {\n    return m && m.type === MARKER;\n}\nfunction isHandshakeRequestMessage(m) {\n    return isMessage(m) && m.action === MessageType.HandshakeRequest;\n}\nfunction isHandshakeResponseMessage(m) {\n    return isMessage(m) && m.action === MessageType.HandshakeResponse;\n}\nfunction isCallMessage(m) {\n    return isMessage(m) && m.action === MessageType.Call;\n}\nfunction isResponseMessage(m) {\n    return isMessage(m) && m.action === MessageType.Response;\n}\nfunction isCallbackMessage(m) {\n    return isMessage(m) && m.action === MessageType.Callback;\n}\nfunction isEventMessage(m) {\n    return isMessage(m) && m.action === MessageType.Event;\n}\n\nfunction makeCallbackEvent(requestId) {\n    return `callback_${requestId}`;\n}\nfunction makeResponseEvent(requestId) {\n    return `response_${requestId}`;\n}\nclass Dispatcher extends ConcreteEmitter {\n    constructor(messenger, sessionId) {\n        super();\n        this.uniqueId = createUniqueIdFn();\n        this.messenger = messenger;\n        this.sessionId = sessionId;\n        this.removeMessengerListener = this.messenger.addMessageListener(this.messengerListener.bind(this));\n    }\n    messengerListener(event) {\n        const { data } = event;\n        if (!isMessage(data)) {\n            return;\n        }\n        if (this.sessionId !== data.sessionId) {\n            return;\n        }\n        if (isCallMessage(data)) {\n            this.emit(MessageType.Call, data);\n        }\n        else if (isResponseMessage(data)) {\n            this.emit(makeResponseEvent(data.requestId), data);\n        }\n        else if (isEventMessage(data)) {\n            this.emit(MessageType.Event, data);\n        }\n        else if (isCallbackMessage(data)) {\n            this.emit(makeCallbackEvent(data.requestId), data);\n        }\n    }\n    callOnRemote(methodName, args, transfer) {\n        const requestId = this.uniqueId();\n        const callbackEvent = makeCallbackEvent(requestId);\n        const responseEvent = makeResponseEvent(requestId);\n        const message = createCallMessage(this.sessionId, requestId, methodName, args);\n        this.messenger.postMessage(message, transfer);\n        return { callbackEvent, responseEvent };\n    }\n    respondToRemote(requestId, value, error, transfer) {\n        if (error instanceof Error) {\n            error = {\n                name: error.name,\n                message: error.message,\n            };\n        }\n        const message = createResponsMessage(this.sessionId, requestId, value, error);\n        this.messenger.postMessage(message, transfer);\n    }\n    callbackToRemote(requestId, callbackId, args) {\n        const message = createCallbackMessage(this.sessionId, requestId, callbackId, args);\n        this.messenger.postMessage(message);\n    }\n    emitToRemote(eventName, payload, transfer) {\n        const message = createEventMessage(this.sessionId, eventName, payload);\n        this.messenger.postMessage(message, transfer);\n    }\n    close() {\n        this.removeMessengerListener();\n        this.removeAllListeners();\n    }\n}\nclass ParentHandshakeDispatcher extends ConcreteEmitter {\n    constructor(messenger, sessionId) {\n        super();\n        this.messenger = messenger;\n        this.sessionId = sessionId;\n        this.removeMessengerListener = this.messenger.addMessageListener(this.messengerListener.bind(this));\n    }\n    messengerListener(event) {\n        const { data } = event;\n        if (!isMessage(data)) {\n            return;\n        }\n        if (this.sessionId !== data.sessionId) {\n            return;\n        }\n        if (isHandshakeResponseMessage(data)) {\n            this.emit(data.sessionId, data);\n        }\n    }\n    initiateHandshake() {\n        const message = createHandshakeRequestMessage(this.sessionId);\n        this.messenger.postMessage(message);\n        return this.sessionId;\n    }\n    close() {\n        this.removeMessengerListener();\n        this.removeAllListeners();\n    }\n}\nclass ChildHandshakeDispatcher extends ConcreteEmitter {\n    constructor(messenger) {\n        super();\n        this.messenger = messenger;\n        this.removeMessengerListener = this.messenger.addMessageListener(this.messengerListener.bind(this));\n    }\n    messengerListener(event) {\n        const { data } = event;\n        if (isHandshakeRequestMessage(data)) {\n            this.emit(MessageType.HandshakeRequest, data);\n        }\n    }\n    acceptHandshake(sessionId) {\n        const message = createHandshakeResponseMessage(sessionId);\n        this.messenger.postMessage(message);\n    }\n    close() {\n        this.removeMessengerListener();\n        this.removeAllListeners();\n    }\n}\n\nvar ProxyType;\n(function (ProxyType) {\n    ProxyType[\"Callback\"] = \"callback\";\n})(ProxyType || (ProxyType = {}));\nfunction createCallbackProxy(callbackId) {\n    return {\n        type: MARKER,\n        proxy: ProxyType.Callback,\n        callbackId,\n    };\n}\nfunction isCallbackProxy(p) {\n    return p && p.type === MARKER && p.proxy === ProxyType.Callback;\n}\n\nclass ConcreteRemoteHandle extends ConcreteEmitter {\n    constructor(dispatcher) {\n        super();\n        this._dispatcher = dispatcher;\n        this._callTransfer = {};\n        this._dispatcher.addEventListener(MessageType.Event, this._handleEvent.bind(this));\n    }\n    close() {\n        this.removeAllListeners();\n    }\n    setCallTransfer(methodName, transfer) {\n        this._callTransfer[methodName] = transfer;\n    }\n    call(methodName, ...args) {\n        return this.customCall(methodName, args);\n    }\n    customCall(methodName, args, options = {}) {\n        return new Promise((resolve, reject) => {\n            const sanitizedArgs = [];\n            const callbacks = [];\n            let callbackId = 0;\n            args.forEach((arg) => {\n                if (typeof arg === 'function') {\n                    callbacks.push(arg);\n                    sanitizedArgs.push(createCallbackProxy(callbackId));\n                    callbackId += 1;\n                }\n                else {\n                    sanitizedArgs.push(arg);\n                }\n            });\n            const hasCallbacks = callbacks.length > 0;\n            let callbackListener = undefined;\n            if (hasCallbacks) {\n                callbackListener = (data) => {\n                    const { callbackId, args } = data;\n                    callbacks[callbackId](...args);\n                };\n            }\n            let transfer = options.transfer;\n            if (transfer === undefined && this._callTransfer[methodName]) {\n                transfer = this._callTransfer[methodName](...sanitizedArgs);\n            }\n            const { callbackEvent, responseEvent } = this._dispatcher.callOnRemote(methodName, sanitizedArgs, transfer);\n            if (hasCallbacks) {\n                this._dispatcher.addEventListener(callbackEvent, callbackListener);\n            }\n            this._dispatcher.once(responseEvent).then((response) => {\n                if (callbackListener) {\n                    this._dispatcher.removeEventListener(callbackEvent, callbackListener);\n                }\n                const { result, error } = response;\n                if (error !== undefined) {\n                    reject(error);\n                }\n                else {\n                    resolve(result);\n                }\n            });\n        });\n    }\n    _handleEvent(data) {\n        const { eventName, payload } = data;\n        this.emit(eventName, payload);\n    }\n}\nclass ConcreteLocalHandle {\n    constructor(dispatcher, localMethods) {\n        this._dispatcher = dispatcher;\n        this._methods = localMethods;\n        this._returnTransfer = {};\n        this._emitTransfer = {};\n        this._dispatcher.addEventListener(MessageType.Call, this._handleCall.bind(this));\n    }\n    emit(eventName, payload, options = {}) {\n        let transfer = options.transfer;\n        if (transfer === undefined && this._emitTransfer[eventName]) {\n            transfer = this._emitTransfer[eventName](payload);\n        }\n        this._dispatcher.emitToRemote(eventName, payload, transfer);\n    }\n    setMethods(methods) {\n        this._methods = methods;\n    }\n    setMethod(methodName, method) {\n        this._methods[methodName] = method;\n    }\n    setReturnTransfer(methodName, transfer) {\n        this._returnTransfer[methodName] = transfer;\n    }\n    setEmitTransfer(eventName, transfer) {\n        this._emitTransfer[eventName] = transfer;\n    }\n    _handleCall(data) {\n        const { requestId, methodName, args } = data;\n        const callMethod = new Promise((resolve, reject) => {\n            const method = this._methods[methodName];\n            if (typeof method !== 'function') {\n                reject(new Error(`The method \"${methodName}\" has not been implemented.`));\n                return;\n            }\n            const desanitizedArgs = args.map((arg) => {\n                if (isCallbackProxy(arg)) {\n                    const { callbackId } = arg;\n                    return (...args) => {\n                        this._dispatcher.callbackToRemote(requestId, callbackId, args);\n                    };\n                }\n                else {\n                    return arg;\n                }\n            });\n            Promise.resolve(this._methods[methodName](...desanitizedArgs))\n                .then(resolve)\n                .catch(reject);\n        });\n        callMethod\n            .then((result) => {\n            let transfer;\n            if (this._returnTransfer[methodName]) {\n                transfer = this._returnTransfer[methodName](result);\n            }\n            this._dispatcher.respondToRemote(requestId, result, undefined, transfer);\n        })\n            .catch((error) => {\n            this._dispatcher.respondToRemote(requestId, undefined, error);\n        });\n    }\n}\n\nclass ConcreteConnection {\n    constructor(dispatcher, localMethods) {\n        this._dispatcher = dispatcher;\n        this._localHandle = new ConcreteLocalHandle(dispatcher, localMethods);\n        this._remoteHandle = new ConcreteRemoteHandle(dispatcher);\n    }\n    close() {\n        this._dispatcher.close();\n        this.remoteHandle().close();\n    }\n    localHandle() {\n        return this._localHandle;\n    }\n    remoteHandle() {\n        return this._remoteHandle;\n    }\n}\n\nconst uniqueSessionId = createUniqueIdFn();\nconst runUntil = (worker, condition, unfulfilled, maxAttempts, attemptInterval) => {\n    let attempt = 0;\n    const fn = () => {\n        if (!condition() && (attempt < maxAttempts || maxAttempts < 1)) {\n            worker();\n            attempt += 1;\n            setTimeout(fn, attemptInterval);\n        }\n        else if (!condition() && attempt >= maxAttempts && maxAttempts >= 1) {\n            unfulfilled();\n        }\n    };\n    fn();\n};\n/**\n * Initiate the handshake from the Parent side\n *\n * @param messenger - The Messenger used to send and receive messages from the other end\n * @param localMethods - The methods that will be exposed to the other end\n * @param maxAttempts - The maximum number of handshake attempts\n * @param attemptsInterval - The interval between handshake attempts\n * @returns A Promise to an active {@link Connection} to the other end\n *\n * @public\n */\nfunction ParentHandshake(messenger, localMethods = {}, maxAttempts = 5, attemptsInterval = 100) {\n    const thisSessionId = uniqueSessionId();\n    let connected = false;\n    return new Promise((resolve, reject) => {\n        const handshakeDispatcher = new ParentHandshakeDispatcher(messenger, thisSessionId);\n        handshakeDispatcher.once(thisSessionId).then((response) => {\n            connected = true;\n            handshakeDispatcher.close();\n            const { sessionId } = response;\n            const dispatcher = new Dispatcher(messenger, sessionId);\n            const connection = new ConcreteConnection(dispatcher, localMethods);\n            resolve(connection);\n        });\n        runUntil(() => handshakeDispatcher.initiateHandshake(), () => connected, () => reject(new Error(`Handshake failed, reached maximum number of attempts`)), maxAttempts, attemptsInterval);\n    });\n}\n/**\n * Initiate the handshake from the Child side\n *\n * @param messenger - The Messenger used to send and receive messages from the other end\n * @param localMethods - The methods that will be exposed to the other end\n * @returns A Promise to an active {@link Connection} to the other end\n *\n * @public\n */\nfunction ChildHandshake(messenger, localMethods = {}) {\n    return new Promise((resolve, reject) => {\n        const handshakeDispatcher = new ChildHandshakeDispatcher(messenger);\n        handshakeDispatcher.once(MessageType.HandshakeRequest).then((response) => {\n            const { sessionId } = response;\n            handshakeDispatcher.acceptHandshake(sessionId);\n            handshakeDispatcher.close();\n            const dispatcher = new Dispatcher(messenger, sessionId);\n            const connection = new ConcreteConnection(dispatcher, localMethods);\n            resolve(connection);\n        });\n    });\n}\n\nconst acceptableMessageEvent = (event, remoteWindow, acceptedOrigin) => {\n    const { source, origin } = event;\n    if (source !== remoteWindow) {\n        return false;\n    }\n    if (origin !== acceptedOrigin && acceptedOrigin !== '*') {\n        return false;\n    }\n    return true;\n};\n/**\n * A concrete implementation of {@link Messenger} used to communicate with another Window.\n *\n * @public\n *\n */\nclass WindowMessenger {\n    constructor({ localWindow, remoteWindow, remoteOrigin, }) {\n        localWindow = localWindow || window;\n        this.postMessage = (message, transfer) => {\n            remoteWindow.postMessage(message, remoteOrigin, transfer);\n        };\n        this.addMessageListener = (listener) => {\n            const outerListener = (event) => {\n                if (acceptableMessageEvent(event, remoteWindow, remoteOrigin)) {\n                    listener(event);\n                }\n            };\n            localWindow.addEventListener('message', outerListener);\n            const removeListener = () => {\n                localWindow.removeEventListener('message', outerListener);\n            };\n            return removeListener;\n        };\n    }\n}\n/** @public */\nclass BareMessenger {\n    constructor(postable) {\n        this.postMessage = (message, transfer = []) => {\n            postable.postMessage(message, transfer);\n        };\n        this.addMessageListener = (listener) => {\n            const outerListener = (event) => {\n                listener(event);\n            };\n            postable.addEventListener('message', outerListener);\n            const removeListener = () => {\n                postable.removeEventListener('message', outerListener);\n            };\n            return removeListener;\n        };\n    }\n}\n/**\n * A concrete implementation of {@link Messenger} used to communicate with a Worker.\n *\n * Takes a {@link Postable} representing the `Worker` (when calling from\n * the parent context) or the `self` `DedicatedWorkerGlobalScope` object\n * (when calling from the child context).\n *\n * @public\n *\n */\nclass WorkerMessenger extends BareMessenger {\n    constructor({ worker }) {\n        super(worker);\n    }\n}\n/**\n * A concrete implementation of {@link Messenger} used to communicate with a MessagePort.\n *\n * @public\n *\n */\nclass PortMessenger extends BareMessenger {\n    constructor({ port }) {\n        port.start();\n        super(port);\n    }\n}\n/**\n * Create a logger function with a specific namespace\n *\n * @param namespace - The namespace will be prepended to all the arguments passed to the logger function\n * @param log - The underlying logger (`console.log` by default)\n *\n * @public\n *\n */\nfunction debug(namespace, log) {\n    log = log || console.debug || console.log || (() => { });\n    return (...data) => {\n        log(namespace, ...data);\n    };\n}\n/**\n * Decorate a {@link Messenger} so that it will log any message exchanged\n * @param messenger - The Messenger that will be decorated\n * @param log - The logger function that will receive each message\n * @returns A decorated Messenger\n *\n * @public\n *\n */\nfunction DebugMessenger(messenger, log) {\n    log = log || debug('post-me');\n    const debugListener = function (event) {\n        const { data } = event;\n        log('⬅️ received message', data);\n    };\n    messenger.addMessageListener(debugListener);\n    return {\n        postMessage: function (message, transfer) {\n            log('➡️ sending message', message);\n            messenger.postMessage(message, transfer);\n        },\n        addMessageListener: function (listener) {\n            return messenger.addMessageListener(listener);\n        },\n    };\n}\n\n\n\n\n/***/ }),\n/* 74 */\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"blobToBase64\": () => (/* binding */ blobToBase64)\n/* harmony export */ });\n/**\n * Convert a blob object to a base64 uri\n *\n * @param {Blob} blob : blob object\n * @returns {Promise.<string>} : base64 form of the blob\n */\nasync function blobToBase64(blob) {\n  const reader = new window.FileReader()\n  await new Promise((resolve, reject) => {\n    reader.onload = resolve\n    reader.onerror = reject\n    reader.readAsDataURL(blob)\n  })\n  return reader.result\n}\n\n\n\n\n/***/ }),\n/* 75 */\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () { 'use strict';\n\n\t/*! MIT License © Sindre Sorhus */\n\n\tconst globals = {};\n\n\tconst getGlobal = property => {\n\t\t/* istanbul ignore next */\n\t\tif (typeof self !== 'undefined' && self && property in self) {\n\t\t\treturn self;\n\t\t}\n\n\t\t/* istanbul ignore next */\n\t\tif (typeof window !== 'undefined' && window && property in window) {\n\t\t\treturn window;\n\t\t}\n\n\t\tif (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g && property in __webpack_require__.g) {\n\t\t\treturn __webpack_require__.g;\n\t\t}\n\n\t\t/* istanbul ignore next */\n\t\tif (typeof globalThis !== 'undefined' && globalThis) {\n\t\t\treturn globalThis;\n\t\t}\n\t};\n\n\tconst globalProperties = [\n\t\t'Headers',\n\t\t'Request',\n\t\t'Response',\n\t\t'ReadableStream',\n\t\t'fetch',\n\t\t'AbortController',\n\t\t'FormData'\n\t];\n\n\tfor (const property of globalProperties) {\n\t\tObject.defineProperty(globals, property, {\n\t\t\tget() {\n\t\t\t\tconst globalObject = getGlobal(property);\n\t\t\t\tconst value = globalObject && globalObject[property];\n\t\t\t\treturn typeof value === 'function' ? value.bind(globalObject) : value;\n\t\t\t}\n\t\t});\n\t}\n\n\tconst isObject = value => value !== null && typeof value === 'object';\n\tconst supportsAbortController = typeof globals.AbortController === 'function';\n\tconst supportsStreams = typeof globals.ReadableStream === 'function';\n\tconst supportsFormData = typeof globals.FormData === 'function';\n\n\tconst mergeHeaders = (source1, source2) => {\n\t\tconst result = new globals.Headers(source1 || {});\n\t\tconst isHeadersInstance = source2 instanceof globals.Headers;\n\t\tconst source = new globals.Headers(source2 || {});\n\n\t\tfor (const [key, value] of source) {\n\t\t\tif ((isHeadersInstance && value === 'undefined') || value === undefined) {\n\t\t\t\tresult.delete(key);\n\t\t\t} else {\n\t\t\t\tresult.set(key, value);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tconst deepMerge = (...sources) => {\n\t\tlet returnValue = {};\n\t\tlet headers = {};\n\n\t\tfor (const source of sources) {\n\t\t\tif (Array.isArray(source)) {\n\t\t\t\tif (!(Array.isArray(returnValue))) {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\n\t\t\t\treturnValue = [...returnValue, ...source];\n\t\t\t} else if (isObject(source)) {\n\t\t\t\tfor (let [key, value] of Object.entries(source)) {\n\t\t\t\t\tif (isObject(value) && (key in returnValue)) {\n\t\t\t\t\t\tvalue = deepMerge(returnValue[key], value);\n\t\t\t\t\t}\n\n\t\t\t\t\treturnValue = {...returnValue, [key]: value};\n\t\t\t\t}\n\n\t\t\t\tif (isObject(source.headers)) {\n\t\t\t\t\theaders = mergeHeaders(headers, source.headers);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturnValue.headers = headers;\n\t\t}\n\n\t\treturn returnValue;\n\t};\n\n\tconst requestMethods = [\n\t\t'get',\n\t\t'post',\n\t\t'put',\n\t\t'patch',\n\t\t'head',\n\t\t'delete'\n\t];\n\n\tconst responseTypes = {\n\t\tjson: 'application/json',\n\t\ttext: 'text/*',\n\t\tformData: 'multipart/form-data',\n\t\tarrayBuffer: '*/*',\n\t\tblob: '*/*'\n\t};\n\n\tconst retryMethods = [\n\t\t'get',\n\t\t'put',\n\t\t'head',\n\t\t'delete',\n\t\t'options',\n\t\t'trace'\n\t];\n\n\tconst retryStatusCodes = [\n\t\t408,\n\t\t413,\n\t\t429,\n\t\t500,\n\t\t502,\n\t\t503,\n\t\t504\n\t];\n\n\tconst retryAfterStatusCodes = [\n\t\t413,\n\t\t429,\n\t\t503\n\t];\n\n\tconst stop = Symbol('stop');\n\n\tclass HTTPError extends Error {\n\t\tconstructor(response) {\n\t\t\t// Set the message to the status text, such as Unauthorized,\n\t\t\t// with some fallbacks. This message should never be undefined.\n\t\t\tsuper(\n\t\t\t\tresponse.statusText ||\n\t\t\t\tString(\n\t\t\t\t\t(response.status === 0 || response.status) ?\n\t\t\t\t\t\tresponse.status : 'Unknown response error'\n\t\t\t\t)\n\t\t\t);\n\t\t\tthis.name = 'HTTPError';\n\t\t\tthis.response = response;\n\t\t}\n\t}\n\n\tclass TimeoutError extends Error {\n\t\tconstructor(request) {\n\t\t\tsuper('Request timed out');\n\t\t\tthis.name = 'TimeoutError';\n\t\t\tthis.request = request;\n\t\t}\n\t}\n\n\tconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n\t// `Promise.race()` workaround (#91)\n\tconst timeout = (request, abortController, options) =>\n\t\tnew Promise((resolve, reject) => {\n\t\t\tconst timeoutID = setTimeout(() => {\n\t\t\t\tif (abortController) {\n\t\t\t\t\tabortController.abort();\n\t\t\t\t}\n\n\t\t\t\treject(new TimeoutError(request));\n\t\t\t}, options.timeout);\n\n\t\t\t/* eslint-disable promise/prefer-await-to-then */\n\t\t\toptions.fetch(request)\n\t\t\t\t.then(resolve)\n\t\t\t\t.catch(reject)\n\t\t\t\t.then(() => {\n\t\t\t\t\tclearTimeout(timeoutID);\n\t\t\t\t});\n\t\t\t/* eslint-enable promise/prefer-await-to-then */\n\t\t});\n\n\tconst normalizeRequestMethod = input => requestMethods.includes(input) ? input.toUpperCase() : input;\n\n\tconst defaultRetryOptions = {\n\t\tlimit: 2,\n\t\tmethods: retryMethods,\n\t\tstatusCodes: retryStatusCodes,\n\t\tafterStatusCodes: retryAfterStatusCodes\n\t};\n\n\tconst normalizeRetryOptions = (retry = {}) => {\n\t\tif (typeof retry === 'number') {\n\t\t\treturn {\n\t\t\t\t...defaultRetryOptions,\n\t\t\t\tlimit: retry\n\t\t\t};\n\t\t}\n\n\t\tif (retry.methods && !Array.isArray(retry.methods)) {\n\t\t\tthrow new Error('retry.methods must be an array');\n\t\t}\n\n\t\tif (retry.statusCodes && !Array.isArray(retry.statusCodes)) {\n\t\t\tthrow new Error('retry.statusCodes must be an array');\n\t\t}\n\n\t\treturn {\n\t\t\t...defaultRetryOptions,\n\t\t\t...retry,\n\t\t\tafterStatusCodes: retryAfterStatusCodes\n\t\t};\n\t};\n\n\t// The maximum value of a 32bit int (see issue #117)\n\tconst maxSafeTimeout = 2147483647;\n\n\tclass Ky {\n\t\tconstructor(input, options = {}) {\n\t\t\tthis._retryCount = 0;\n\t\t\tthis._input = input;\n\t\t\tthis._options = {\n\t\t\t\t// TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208\n\t\t\t\tcredentials: this._input.credentials || 'same-origin',\n\t\t\t\t...options,\n\t\t\t\theaders: mergeHeaders(this._input.headers, options.headers),\n\t\t\t\thooks: deepMerge({\n\t\t\t\t\tbeforeRequest: [],\n\t\t\t\t\tbeforeRetry: [],\n\t\t\t\t\tafterResponse: []\n\t\t\t\t}, options.hooks),\n\t\t\t\tmethod: normalizeRequestMethod(options.method || this._input.method),\n\t\t\t\tprefixUrl: String(options.prefixUrl || ''),\n\t\t\t\tretry: normalizeRetryOptions(options.retry),\n\t\t\t\tthrowHttpErrors: options.throwHttpErrors !== false,\n\t\t\t\ttimeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,\n\t\t\t\tfetch: options.fetch || globals.fetch\n\t\t\t};\n\n\t\t\tif (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globals.Request)) {\n\t\t\t\tthrow new TypeError('`input` must be a string, URL, or Request');\n\t\t\t}\n\n\t\t\tif (this._options.prefixUrl && typeof this._input === 'string') {\n\t\t\t\tif (this._input.startsWith('/')) {\n\t\t\t\t\tthrow new Error('`input` must not begin with a slash when using `prefixUrl`');\n\t\t\t\t}\n\n\t\t\t\tif (!this._options.prefixUrl.endsWith('/')) {\n\t\t\t\t\tthis._options.prefixUrl += '/';\n\t\t\t\t}\n\n\t\t\t\tthis._input = this._options.prefixUrl + this._input;\n\t\t\t}\n\n\t\t\tif (supportsAbortController) {\n\t\t\t\tthis.abortController = new globals.AbortController();\n\t\t\t\tif (this._options.signal) {\n\t\t\t\t\tthis._options.signal.addEventListener('abort', () => {\n\t\t\t\t\t\tthis.abortController.abort();\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._options.signal = this.abortController.signal;\n\t\t\t}\n\n\t\t\tthis.request = new globals.Request(this._input, this._options);\n\n\t\t\tif (this._options.searchParams) {\n\t\t\t\tconst searchParams = '?' + new URLSearchParams(this._options.searchParams).toString();\n\t\t\t\tconst url = this.request.url.replace(/(?:\\?.*?)?(?=#|$)/, searchParams);\n\n\t\t\t\t// To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one\n\t\t\t\tif (((supportsFormData && this._options.body instanceof globals.FormData) || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {\n\t\t\t\t\tthis.request.headers.delete('content-type');\n\t\t\t\t}\n\n\t\t\t\tthis.request = new globals.Request(new globals.Request(url, this.request), this._options);\n\t\t\t}\n\n\t\t\tif (this._options.json !== undefined) {\n\t\t\t\tthis._options.body = JSON.stringify(this._options.json);\n\t\t\t\tthis.request.headers.set('content-type', 'application/json');\n\t\t\t\tthis.request = new globals.Request(this.request, {body: this._options.body});\n\t\t\t}\n\n\t\t\tconst fn = async () => {\n\t\t\t\tif (this._options.timeout > maxSafeTimeout) {\n\t\t\t\t\tthrow new RangeError(`The \\`timeout\\` option cannot be greater than ${maxSafeTimeout}`);\n\t\t\t\t}\n\n\t\t\t\tawait delay(1);\n\t\t\t\tlet response = await this._fetch();\n\n\t\t\t\tfor (const hook of this._options.hooks.afterResponse) {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tconst modifiedResponse = await hook(\n\t\t\t\t\t\tthis.request,\n\t\t\t\t\t\tthis._options,\n\t\t\t\t\t\tthis._decorateResponse(response.clone())\n\t\t\t\t\t);\n\n\t\t\t\t\tif (modifiedResponse instanceof globals.Response) {\n\t\t\t\t\t\tresponse = modifiedResponse;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._decorateResponse(response);\n\n\t\t\t\tif (!response.ok && this._options.throwHttpErrors) {\n\t\t\t\t\tthrow new HTTPError(response);\n\t\t\t\t}\n\n\t\t\t\t// If `onDownloadProgress` is passed, it uses the stream API internally\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (this._options.onDownloadProgress) {\n\t\t\t\t\tif (typeof this._options.onDownloadProgress !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('The `onDownloadProgress` option must be a function');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!supportsStreams) {\n\t\t\t\t\t\tthrow new Error('Streams are not supported in your environment. `ReadableStream` is missing.');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this._stream(response.clone(), this._options.onDownloadProgress);\n\t\t\t\t}\n\n\t\t\t\treturn response;\n\t\t\t};\n\n\t\t\tconst isRetriableMethod = this._options.retry.methods.includes(this.request.method.toLowerCase());\n\t\t\tconst result = isRetriableMethod ? this._retry(fn) : fn();\n\n\t\t\tfor (const [type, mimeType] of Object.entries(responseTypes)) {\n\t\t\t\tresult[type] = async () => {\n\t\t\t\t\tthis.request.headers.set('accept', this.request.headers.get('accept') || mimeType);\n\n\t\t\t\t\tconst response = (await result).clone();\n\n\t\t\t\t\tif (type === 'json') {\n\t\t\t\t\t\tif (response.status === 204) {\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (options.parseJson) {\n\t\t\t\t\t\t\treturn options.parseJson(await response.text());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn response[type]();\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t_calculateRetryDelay(error) {\n\t\t\tthis._retryCount++;\n\n\t\t\tif (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {\n\t\t\t\tif (error instanceof HTTPError) {\n\t\t\t\t\tif (!this._options.retry.statusCodes.includes(error.response.status)) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst retryAfter = error.response.headers.get('Retry-After');\n\t\t\t\t\tif (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {\n\t\t\t\t\t\tlet after = Number(retryAfter);\n\t\t\t\t\t\tif (Number.isNaN(after)) {\n\t\t\t\t\t\t\tafter = Date.parse(retryAfter) - Date.now();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tafter *= 1000;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn after;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error.response.status === 413) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst BACKOFF_FACTOR = 0.3;\n\t\t\t\treturn BACKOFF_FACTOR * (2 ** (this._retryCount - 1)) * 1000;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t_decorateResponse(response) {\n\t\t\tif (this._options.parseJson) {\n\t\t\t\tresponse.json = async () => {\n\t\t\t\t\treturn this._options.parseJson(await response.text());\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn response;\n\t\t}\n\n\t\tasync _retry(fn) {\n\t\t\ttry {\n\t\t\t\treturn await fn();\n\t\t\t} catch (error) {\n\t\t\t\tconst ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);\n\t\t\t\tif (ms !== 0 && this._retryCount > 0) {\n\t\t\t\t\tawait delay(ms);\n\n\t\t\t\t\tfor (const hook of this._options.hooks.beforeRetry) {\n\t\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\t\tconst hookResult = await hook({\n\t\t\t\t\t\t\trequest: this.request,\n\t\t\t\t\t\t\toptions: this._options,\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\tretryCount: this._retryCount\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// If `stop` is returned from the hook, the retry process is stopped\n\t\t\t\t\t\tif (hookResult === stop) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this._retry(fn);\n\t\t\t\t}\n\n\t\t\t\tif (this._options.throwHttpErrors) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync _fetch() {\n\t\t\tfor (const hook of this._options.hooks.beforeRequest) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tconst result = await hook(this.request, this._options);\n\n\t\t\t\tif (result instanceof Request) {\n\t\t\t\t\tthis.request = result;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (result instanceof Response) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._options.timeout === false) {\n\t\t\t\treturn this._options.fetch(this.request.clone());\n\t\t\t}\n\n\t\t\treturn timeout(this.request.clone(), this.abortController, this._options);\n\t\t}\n\n\t\t/* istanbul ignore next */\n\t\t_stream(response, onDownloadProgress) {\n\t\t\tconst totalBytes = Number(response.headers.get('content-length')) || 0;\n\t\t\tlet transferredBytes = 0;\n\n\t\t\treturn new globals.Response(\n\t\t\t\tnew globals.ReadableStream({\n\t\t\t\t\tstart(controller) {\n\t\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\t\tif (onDownloadProgress) {\n\t\t\t\t\t\t\tonDownloadProgress({percent: 0, transferredBytes: 0, totalBytes}, new Uint8Array());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tasync function read() {\n\t\t\t\t\t\t\tconst {done, value} = await reader.read();\n\t\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (onDownloadProgress) {\n\t\t\t\t\t\t\t\ttransferredBytes += value.byteLength;\n\t\t\t\t\t\t\t\tconst percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;\n\t\t\t\t\t\t\t\tonDownloadProgress({percent, transferredBytes, totalBytes}, value);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontroller.enqueue(value);\n\t\t\t\t\t\t\tread();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tread();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n\n\tconst validateAndMerge = (...sources) => {\n\t\tfor (const source of sources) {\n\t\t\tif ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {\n\t\t\t\tthrow new TypeError('The `options` argument must be an object');\n\t\t\t}\n\t\t}\n\n\t\treturn deepMerge({}, ...sources);\n\t};\n\n\tconst createInstance = defaults => {\n\t\tconst ky = (input, options) => new Ky(input, validateAndMerge(defaults, options));\n\n\t\tfor (const method of requestMethods) {\n\t\t\tky[method] = (input, options) => new Ky(input, validateAndMerge(defaults, options, {method}));\n\t\t}\n\n\t\tky.HTTPError = HTTPError;\n\t\tky.TimeoutError = TimeoutError;\n\t\tky.create = newDefaults => createInstance(validateAndMerge(newDefaults));\n\t\tky.extend = newDefaults => createInstance(validateAndMerge(defaults, newDefaults));\n\t\tky.stop = stop;\n\n\t\treturn ky;\n\t};\n\n\tvar index = createInstance();\n\n\treturn index;\n\n})));\n\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__webpack_require__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/global */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n(() => {\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var cozy_ccc_libs_src_contentscript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _cozy_minilog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);\n/* harmony import */ var _cozy_minilog__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_cozy_minilog__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst log = _cozy_minilog__WEBPACK_IMPORTED_MODULE_1___default()('ContentScript')\n_cozy_minilog__WEBPACK_IMPORTED_MODULE_1___default().enable()\n\nconst baseUrl = 'http://toscrape.com'\nconst defaultSelector = \"a[href='http://quotes.toscrape.com']\"\nconst loginLinkSelector = `[href='/login']`\nconst logoutLinkSelector = `[href='/logout']`\n\nclass TemplateContentScript extends cozy_ccc_libs_src_contentscript__WEBPACK_IMPORTED_MODULE_0__.ContentScript {\n  async ensureAuthenticated() {\n    await this.goto(baseUrl)\n    await this.waitForElementInWorker(defaultSelector)\n    await this.runInWorker('click', defaultSelector)\n    // wait for both logout or login link to be sure to check authentication when ready\n    await Promise.race([\n      this.waitForElementInWorker(loginLinkSelector),\n      this.waitForElementInWorker(logoutLinkSelector)\n    ])\n    const authenticated = await this.runInWorker('checkAuthenticated')\n    if (!authenticated) {\n      this.log('not authenticated')\n      await this.showLoginFormAndWaitForAuthentication()\n    }\n    return true\n  }\n\n  async checkAuthenticated() {\n    return Boolean(document.querySelector(logoutLinkSelector))\n  }\n\n  async showLoginFormAndWaitForAuthentication() {\n    log.debug('showLoginFormAndWaitForAuthentication start')\n    await this.clickAndWait(loginLinkSelector, '#username')\n    await this.setWorkerState({ visible: true })\n    await this.runInWorkerUntilTrue({\n      method: 'waitForAuthenticated'\n    })\n    await this.setWorkerState({ visible: false })\n  }\n\n  async fetch(context) {\n    log.debug(context, 'fetch context')\n    const bookLinkSelector = `[href*='books.toscrape.com']`\n    await this.goto(baseUrl + '/index.html')\n    await this.waitForElementInWorker(bookLinkSelector)\n    await this.clickAndWait(bookLinkSelector, '#promotions')\n    const bills = await this.runInWorker('parseBills')\n\n    await this.saveFiles(bills, {\n      contentType: 'image/jpeg',\n      fileIdAttributes: ['filename'],\n      context\n    })\n  }\n\n  async getUserDataFromWebsite() {\n    return {\n      sourceAccountIdentifier: 'defaultTemplateSourceAccountIdentifier'\n    }\n  }\n\n  async parseBills() {\n    const articles = document.querySelectorAll('article')\n    return Array.from(articles).map(article => ({\n      amount: normalizePrice(article.querySelector('.price_color')?.innerHTML),\n      filename: article.querySelector('h3 a')?.getAttribute('title'),\n      fileurl:\n        'https://books.toscrape.com/' +\n        article.querySelector('img')?.getAttribute('src')\n    }))\n  }\n}\n\n// Convert a price string to a float\nfunction normalizePrice(price) {\n  return parseFloat(price.replace('£', '').trim())\n}\n\nconst connector = new TemplateContentScript()\nconnector.init({ additionalExposedMethodsNames: ['parseBills'] }).catch(err => {\n  log.warn(err)\n})\n\n})();\n\n/******/ })()\n;",
  manifest: {
  "version": "1.0.0",
  "name": "Template",
  "type": "konnector",
  "language": "node",
  "icon": "icon.svg",
  "slug": "template",
  "source": "git@github.com:konnectors/template.git",
  "editor": "Cozy",
  "vendor_link": "https://books.toscrape.com/",
  "categories": [
    "transport"
  ],
  "fields": { },
  "clientSide": true
}
}